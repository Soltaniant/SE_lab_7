# 1: Use Polymorphism

کلاس `CodeGenerator` دارای یک switchCase بسیار بزرگ است که به وضوح به نقض اصل Open-Closed پرداخته است. حال آنکه می‌توان به جای اینکه رفتار مورد نظر را بر اساس نوع تابع و از طریق این switchCase فراخوانی کرد، می‌توان از رویکرد polymorphic استفاده کرده و آن را در قالب کلاس‌های مجزا تحت عنوان Operator انجام دهیم.
در نتیجه، کلاس‌های مختلف پکیج Operators را بر همین اساس ایجاد و از الگوی Strategy استفاده کردیم.

همچنین برای رجیستر شدن پیاده‌سازی‌های مختلف اینترفیس Operator از مکانیزم reflection در جاوا استفاده کردیم تا فرایند رجیستر شدن به صورت اتومات صورت بگیرد و اصل OCP به صورت تمیز‌تری رعایت شود.

# 2: Separate Query from Modifier

در کلاس `Memory` متود `getTemp()` را به دو متود `getTemp` و `updateTempIndex` شکستیم.
همچنین برای متود `getDateAddress` نیز چنین کردیم.

# 3: Self-Encapsulated Field

در همان کلاس `Memory` برای فیلد `codeblock` یک `protected getter` اضافه کردیم و در دیگر قسمت‌های کلاس از آن استفاده نمودیم.
همچنین برای کلاس داخلی _`3AddressCode` مشابه این کار را انجام دادیم. توجه شود که در این کلاس داخلی، فیلد‌ها نیز به صورت `public` تعریف شده‌بودند که آن‌ها نیز به حالت `private` تغییر داده شدند.
