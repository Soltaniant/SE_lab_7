# 1: Use Polymorphism

کلاس `CodeGenerator` دارای یک switchCase بسیار بزرگ است که به وضوح به نقض اصل Open-Closed پرداخته است. حال آنکه می‌توان به جای اینکه رفتار مورد نظر را بر اساس نوع تابع و از طریق این switchCase فراخوانی کرد، می‌توان از رویکرد polymorphic استفاده کرده و آن را در قالب کلاس‌های مجزا تحت عنوان Operator انجام دهیم.
در نتیجه، کلاس‌های مختلف پکیج Operators را بر همین اساس ایجاد و از الگوی Strategy استفاده کردیم.

همچنین برای رجیستر شدن پیاده‌سازی‌های مختلف اینترفیس Operator از مکانیزم reflection در جاوا استفاده کردیم تا فرایند رجیستر شدن به صورت اتومات صورت بگیرد و اصل OCP به صورت تمیز‌تری رعایت شود.

# 2: Separate Query from Modifier

در کلاس `Memory` متود `getTemp()` را به دو متود `getTemp` و `updateTempIndex` شکستیم.
همچنین برای متود `getDateAddress` نیز چنین کردیم.

# 3: Self-Encapsulated Field

در همان کلاس `Memory` برای فیلد `codeblock` یک `protected getter` اضافه کردیم و در دیگر قسمت‌های کلاس از آن استفاده نمودیم.
همچنین برای کلاس داخلی _`3AddressCode` مشابه این کار را انجام دادیم. توجه شود که در این کلاس داخلی، فیلد‌ها نیز به صورت `public` تعریف شده‌بودند که آن‌ها نیز به حالت `private` تغییر داده شدند.

# 4: Extract Method

در کلاس parseTable یک فرایند initialization داشتیم که آن را به سه متود کوچکتر شکاندیم. البته که شکاندن متود‌ها به حالت‌های ریزتر نیز امکان‌پذیر بود اما صرفا در این تمرین به انجام یکی از این حالات بسنده نمودیم.
به طور مثال بسیاری از عبارات درون if، قابل استخراج هستند تا در یک متود با نام مناسب و معنای بیشتر شرط آن‌ها چک شود.

# 5: Extract Class
با توجه به اینکه در برخی موارد لازم بود متن فایل‌ها مورد استفاده قرار بگیرد، تلاش شد که استفاده گسترده و نامتعارف از عملیات‌های مربوط به خواندن فایل، در یک کلاس واحد FileReader مجتمع شود و استفاده‌های فعلی با فراخوانی توابع این کلاس جایگزین شوند.

# 6: Facade
برای انجام `Facade` از دو کلاس Parser و Memory استفاده می‌کنیم. کلاس Parser برای پیاده‌سازی Facade مناسب است، زیرا این کلاس از چندین سیستم و عملیات پیچیده استفاده می‌کند که می‌توانند در یک رابط ساده‌تر و یکپارچه توسط یک `Facade` مدیریت شوند. این سیستم‌های پیچیده شامل اجزای مختلفی هستند که در صورتی که کاربر بخواهد به‌طور مستقیم از آن‌ها استفاده کند، پیچیدگی زیادی را به دنبال خواهند داشت. 
کلاس Memory نیز برای ایجاد یک Facade مناسب‌ است به این دلیل که این کلاس بیشتر با داده‌ها و آدرس‌ها سر و کار دارد و شامل عملیات‌هایی است که می‌توان آن‌ها را در یک `Facade` ساده و یکپارچه‌سازی شده قرار داد. 
